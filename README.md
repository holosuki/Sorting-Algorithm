# Sorting-Algorithm
## 项目简介：

​		1.自主总结了多种排序算法，编写了一个排序模板类。

​		2.对多种算法进行测试，体现出算法的对比结果。

​		3.基于vector作为传入参数。

## 项目内容：

### 1.冒泡排序

​		两两对比，比较相邻的元素，大的放后面；一轮之后最大的处于末尾。时间复杂度$O(n^2)$。

​		在基本的冒泡排序的基础上进行了优化，记录下最后一次交换的位置，减少迭代次数。

### 2.选择排序

​		找出最大的值，交换到末尾（或者最小到前面）。时间复杂度$O(n^2)$，最好情况下也是$O(n^2)$。

### 3.堆排序

​		利用堆来进行选择最大值，可以看作选择排序的优化，效率高。时间复杂度$O(nlogn+n)$，也就是$O(nlogn)$。不稳定。空间复杂度$O(1)$。

​		实现过程中没有使用c++stl库中的priority_queue，而是自己实现了大根堆的create_heap和pop_heap的过程。

### 4.插入排序

​		从头开始，依次把后面的数按照顺序插入数列中。其实实现起来也就是和前一个数比较交换只到有序。时间复杂度最差、平均$O(n^2)$，最好$O(n)$。空间复杂度$O(1)$。稳定。

​		可以使用二分查找的方式优化查找方法。不过由于插入过程需要对后续的数组均进行移动，所以本次实现过程中直接将移动和比较放在一起写了，当然相对来说还是二分查找+移动效率高一点。

### 5.归并排序

​		将数列分割至n组一个数据的数列，然后两两合并，合并时排序成有序的数列，最后变成有序的原数列。分为分割，合并两步。时间复杂度，级数运算，最好最坏平均都是$O(nlogn)$。空间复杂度$O(n)$。稳定。对比来说比堆排序快。

### 6.快速排序

​		选择一个轴点元素，比它大的放他右边，小的放他左边，以此分成两个序列，依次往下分割。时间复杂度，左右元素比较均匀的时候最好$O(nlogn)$，平均也是，只有比轴点元素大或者小的时候最差$O(n^2)$。

### 7.希尔排序

​		希尔排序把序列看作是一个矩阵，分成m列，逐列进行排序；m从某个整数逐渐减为1，当m为1时，整个序列将完全有序。矩阵的列数取决于步长序列(step sequence)，比如，如果步长序列为{1,5,19,41,109...}，就代表依次分成109列、41列、19列、5列、1列不同的步长序列，执行效率也不同。希尔自己的步长序列是$n/2^k$。分列完之后用插入排序进行底层的排序，因为插入排序因逆序对的减少而效率增加。

​		实现过程采用的步长序列是，Robert Sedgewick提出的，最坏时间复杂度为$O(n^{4/3})$。
$$
step = \left\{ \begin{array}{rcl} 9*(2^k-2^{\frac{k}{2}}) + 1 & \mbox{for} & k = even \\
8*2^k-6*2^{\frac{k+1}{2}} + 1 & \mbox{for} & k = odd \end{array} \right.
$$
​		不过，由于插入排序用的上述插入排序的变种，还是有优化的空间。


